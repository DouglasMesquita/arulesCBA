barplot(means, las = 2)
abline(h=mean(means), col="red")
barplot(sort(means, descending=TRUE), las = 2)
barplot(sort(means, decreasing=TRUE), las = 2)
abline(h=mean(means), col="red")
length(means)
cols <- colorRampPalette(c("navy", "white"))(length(means))
barplot(sort(means, decreasing=TRUE), las = 2, col = cols)
abline(h=mean(means), col="red")
means <- colSum(cor(agg[,-1]))
par( mar=c(15,5,1,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols)
means <- colSums(cor(agg[,-1]))
par( mar=c(15,5,1,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols)
abline(h=mean(means), col="red")
cols <- colorRampPalette(c("deepskyblue3", "white"))(length(means))
#par(op)
means <- colSums(cor(agg[,-1]))
par( mar=c(15,5,1,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols)
abline(h=mean(means), col="red")
rm(list = ls())
load("data_clean.rda")
zips <- sort(table(data_clean$ZipCode))
length(zips)
zips[50:105]
barplot(zips[75:105])
summary(data_clean$City)
data_clean$City[data_clean$City == 'D'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DAL'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALAS'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALLA'] <- 'DALLAS'
data_clean$City[data_clean$City == 'Dallas'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DLS'] <- 'DALLAS'
data_clean$City[data_clean$City == ""] <- NA
data_clean$City = factor(data_clean$City)
summary(data_clean$City)
barplot(sort(table(data_clean$Beat), decreasing = TRUE), main = "Reports per Beat")
agg <- aggregate(UCROffDesc ~ Beat, FUN = table, data = data_clean)
agg$t <- agg$UCROffDesc
agg$UCROffDesc <- NULL
boxplot(agg$t[,6:8])
op <- par(no.readonly = TRUE)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(as.matrix(agg)[,2:34], main = "Reports by Type", las = 2)
par(op)
summary(agg$t[,6])
agg$Beat[agg$t[,6] >= 35]
head(agg$t[,6])
for(i in 7:11){
oldpar <- par(mar=c(15,4,4,2)+.1)
barplot(agg[i,-1]/colMeans(agg[,-1], na.rm = T), las=2,
main = paste("Beat:", agg[i,1]), ylab = "Lift")
abline(h=1, col="red")
par(oldpar)
}
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(colMeans(agg[,-1]),las=2, main="Mean Reports per Type")
abline(h=mean(colMeans(agg[,-1])), col="red")
par(op)
require(corrplot)
corrplot(cor(agg[,-1]), method="ellipse", mar=c(1,0,1,0))
correlations <- cor(agg[,-1])
correlations[1,25:30]
cols <- colorRampPalette(c("deepskyblue3", "white"))(length(means))
#par(op)
means <- colSums(cor(agg[,-1]))
par( mar=c(15,5,1,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols, main = "Predictive Value of Each Type")
abline(h=mean(means), col="red")
length(means)
rm(list = ls())
load("data_clean.rda")
zips <- sort(table(data_clean$ZipCode))
length(zips)
zips[50:105]
barplot(zips[75:105])
summary(data_clean$City)
data_clean$City[data_clean$City == 'D'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DAL'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALAS'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALLA'] <- 'DALLAS'
data_clean$City[data_clean$City == 'Dallas'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DLS'] <- 'DALLAS'
data_clean$City[data_clean$City == ""] <- NA
data_clean$City = factor(data_clean$City)
summary(data_clean$City)
barplot(sort(table(data_clean$Beat), decreasing = TRUE), main = "Reports per Beat")
agg <- aggregate(UCROffDesc ~ Beat, FUN = table, data = data_clean)
agg$t <- agg$UCROffDesc
agg$UCROffDesc <- NULL
boxplot(agg$t[,6:8])
op <- par(no.readonly = TRUE)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(as.matrix(agg)[,2:34], main = "Reports by Type", las = 2)
par(op)
summary(agg$t[,6])
agg$Beat[agg$t[,6] >= 35]
head(agg$t[,6])
for(i in 7:11){
oldpar <- par(mar=c(15,4,4,2)+.1)
barplot(agg[i,-1]/colMeans(agg[,-1], na.rm = T), las=2,
main = paste("Beat:", agg[i,1]), ylab = "Lift")
abline(h=1, col="red")
par(oldpar)
}
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(colMeans(agg[,-1]),las=2, main="Mean Reports per Type")
abline(h=mean(colMeans(agg[,-1])), col="red")
par(op)
require(corrplot)
corrplot(cor(agg[,-1]), method="ellipse", mar=c(1,0,1,0))
correlations <- cor(agg[,-1])
correlations[1,25:30]
#par(op)
means <- colSums(cor(agg[,-1]))
cols <- colorRampPalette(c("deepskyblue3", "white"))(length(means))
par( mar=c(15,5,1,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols, main = "Predictive Value of Each Type")
abline(h=mean(means), col="red")
length(means)
rm(list = ls())
par( mar=c(15,5,2,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols, main = "Predictive Value of Each Type")
load("data_clean.rda")
zips <- sort(table(data_clean$ZipCode))
length(zips)
zips[50:105]
barplot(zips[75:105])
summary(data_clean$City)
data_clean$City[data_clean$City == 'D'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DAL'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALAS'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALLA'] <- 'DALLAS'
data_clean$City[data_clean$City == 'Dallas'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DLS'] <- 'DALLAS'
data_clean$City[data_clean$City == ""] <- NA
data_clean$City = factor(data_clean$City)
summary(data_clean$City)
barplot(sort(table(data_clean$Beat), decreasing = TRUE), main = "Reports per Beat")
agg <- aggregate(UCROffDesc ~ Beat, FUN = table, data = data_clean)
agg$t <- agg$UCROffDesc
agg$UCROffDesc <- NULL
boxplot(agg$t[,6:8])
op <- par(no.readonly = TRUE)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(as.matrix(agg)[,2:34], main = "Reports by Type", las = 2)
par(op)
summary(agg$t[,6])
agg$Beat[agg$t[,6] >= 35]
head(agg$t[,6])
for(i in 7:11){
oldpar <- par(mar=c(15,4,4,2)+.1)
barplot(agg[i,-1]/colMeans(agg[,-1], na.rm = T), las=2,
main = paste("Beat:", agg[i,1]), ylab = "Lift")
abline(h=1, col="red")
par(oldpar)
}
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(colMeans(agg[,-1]),las=2, main="Mean Reports per Type")
abline(h=mean(colMeans(agg[,-1])), col="red")
par(op)
require(corrplot)
corrplot(cor(agg[,-1]), method="ellipse", mar=c(1,0,1,0))
correlations <- cor(agg[,-1])
correlations[1,25:30]
#par(op)
means <- colSums(cor(agg[,-1]))
cols <- colorRampPalette(c("deepskyblue3", "white"))(length(means))
par( mar=c(15,5,2,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols, main = "Predictive Value of Each Type")
abline(h=mean(means), col="red")
length(means)
rm(list = ls())
barplot(sort(colMeans(agg[,-1]), decreasing=TRUE),las=2, main="Mean Reports per Type")
load("data_clean.rda")
zips <- sort(table(data_clean$ZipCode))
length(zips)
zips[50:105]
barplot(zips[75:105])
summary(data_clean$City)
data_clean$City[data_clean$City == 'D'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DAL'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALAS'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALLA'] <- 'DALLAS'
data_clean$City[data_clean$City == 'Dallas'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DLS'] <- 'DALLAS'
data_clean$City[data_clean$City == ""] <- NA
data_clean$City = factor(data_clean$City)
summary(data_clean$City)
barplot(sort(table(data_clean$Beat), decreasing = TRUE), main = "Reports per Beat")
agg <- aggregate(UCROffDesc ~ Beat, FUN = table, data = data_clean)
agg$t <- agg$UCROffDesc
agg$UCROffDesc <- NULL
boxplot(agg$t[,6:8])
op <- par(no.readonly = TRUE)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(as.matrix(agg)[,2:34], main = "Reports by Type", las = 2)
par(op)
summary(agg$t[,6])
agg$Beat[agg$t[,6] >= 35]
head(agg$t[,6])
for(i in 7:11){
oldpar <- par(mar=c(15,4,4,2)+.1)
barplot(agg[i,-1]/colMeans(agg[,-1], na.rm = T), las=2,
main = paste("Beat:", agg[i,1]), ylab = "Lift")
abline(h=1, col="red")
par(oldpar)
}
cols <- colorRampPalette(c("firebrick", "white"))(length(agg[,-1]))
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(sort(colMeans(agg[,-1]), decreasing=TRUE),las=2, main="Mean Reports per Type")
abline(h=mean(colMeans(agg[,-1])), col=cols)
par(op)
require(corrplot)
corrplot(cor(agg[,-1]), method="ellipse", mar=c(1,0,1,0))
correlations <- cor(agg[,-1])
correlations[1,25:30]
#par(op)
means <- colSums(cor(agg[,-1]))
cols <- colorRampPalette(c("deepskyblue3", "white"))(length(means))
par( mar=c(15,5,2,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols, main = "Predictive Value of Each Type")
abline(h=mean(means), col="red")
cols <- colorRampPalette(c("firebrick", "white"))(length(agg[,-1]))
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(sort(colMeans(agg[,-1]), decreasing=TRUE),las=2, main="Mean Reports per Type")
abline(h=mean(colMeans(agg[,-1])), col=cols)
par(op)
cols <- colorRampPalette(c("firebrick", "white"))(length(agg[,-1]))
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(sort(colMeans(agg[,-1]), decreasing=TRUE),las=2, main="Mean Reports per Type", col=cols)
abline(h=mean(colMeans(agg[,-1])), col="red")
par(op)
cols <- colorRampPalette(c("firebrick", "white"))(35)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(sort(colMeans(agg[,-1]), decreasing=TRUE),las=2, main="Mean Reports per Type", col=cols)
abline(h=mean(colMeans(agg[,-1])), col="red")
abline(h=mean(colMeans(agg[,-1])), col="blue")
load("data_clean.rda")
zips <- sort(table(data_clean$ZipCode))
length(zips)
zips[50:105]
barplot(zips[75:105])
summary(data_clean$City)
data_clean$City[data_clean$City == 'D'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DAL'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALAS'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DALLA'] <- 'DALLAS'
data_clean$City[data_clean$City == 'Dallas'] <- 'DALLAS'
data_clean$City[data_clean$City == 'DLS'] <- 'DALLAS'
data_clean$City[data_clean$City == ""] <- NA
data_clean$City = factor(data_clean$City)
summary(data_clean$City)
barplot(sort(table(data_clean$Beat), decreasing = TRUE), main = "Reports per Beat")
agg <- aggregate(UCROffDesc ~ Beat, FUN = table, data = data_clean)
agg$t <- agg$UCROffDesc
agg$UCROffDesc <- NULL
boxplot(agg$t[,6:8])
op <- par(no.readonly = TRUE)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(as.matrix(agg)[,2:34], main = "Reports by Type", las = 2)
par(op)
summary(agg$t[,6])
agg$Beat[agg$t[,6] >= 35]
head(agg$t[,6])
for(i in 7:11){
oldpar <- par(mar=c(15,4,4,2)+.1)
barplot(agg[i,-1]/colMeans(agg[,-1], na.rm = T), las=2,
main = paste("Beat:", agg[i,1]), ylab = "Lift")
abline(h=1, col="red")
par(oldpar)
}
cols <- colorRampPalette(c("firebrick", "white"))(35)
par(mar=c(15, 5, 2, 2) + 0.1)
barplot(sort(colMeans(agg[,-1]), decreasing=TRUE),las=2, main="Mean Reports per Type", col=cols)
abline(h=mean(colMeans(agg[,-1])), col="blue")
par(op)
require(corrplot)
corrplot(cor(agg[,-1]), method="ellipse", mar=c(1,0,1,0))
correlations <- cor(agg[,-1])
correlations[1,25:30]
#par(op)
means <- colSums(cor(agg[,-1]))
cols <- colorRampPalette(c("deepskyblue3", "white"))(length(means))
par( mar=c(15,5,2,5)+.1)
barplot(sort(means, decreasing=TRUE), las = 2, col = cols, main = "Predictive Value of Each Type")
abline(h=mean(means), col="red")
str(titanic.raw)
setwd("~/Dropbox/Summer 2016/CSE 5390/5331 Project 1/")
load("titanic.raw.rdata")
setwd("~/Dropbox/Summer 2016/CSE 5390/")
load("titanic.raw.rdata")
str(titanic.raw)
require(arules)
install.packages("arules")
require(arules)
install.packages(arules)
install.packages("arules")
install.packages("arules")
install.packages("arules")
rm(list = ls())
setwd("~/Dropbox/Summer 2016/CSE 5390/")
load("titanic.raw.rdata")
str(titanic.raw)
install.packages("arules")
require(arules)
rules <- apriori(titanic.raw)
setwd("~/Dropbox/Summer 2016/CSE 5390/CBA_Algorithm")
load("titanic.raw.rdata")
str(titanic.raw)
require(arules)
rules <- apriori(titanic.raw, parameter = list(minlen=2, supp=0.005, conf=0.6), appearance = list(rhs=c("Survived=No", "Survived=Yes"), default="lhs"), control=list(verbose=FALSE))
rules.sorted <- sort(rules, by=c("confidence", "support", "lift"))
inspect(rules.sorted)
#subset.matrix <- is.subset(rules.sorted, rules.sorted)
#subset.matrix[lower.tri(subset.matrix, diag = TRUE)] <- NA
#redundant <- colSums(subset.matrix, na.rm = TRUE) >= 1
#which(redundant)
#rules.pruned <- rules.sorted[!redundant]
rules.pruned <- rules.sorted
inspect(rules.pruned)
titanic.mat <- as(titanic.raw, "transactions")
rulesMatchLHS <- is.subset(rules.pruned@lhs, titanic.mat)
rulesMatchRHS <- is.subset(rules.pruned@rhs, titanic.mat)
matches <- rulesMatchLHS & rulesMatchRHS
falseMatches <- rulesMatchLHS & !rulesMatchRHS
table(matches)
table(falseMatches)
inspect(rules.pruned)
#for(i in 1:2201){
#  inspect(rules.pruned[falseMatches[,i]])
#}
correct <- apply(matches, 2, function(x) Reduce("|", x))
table(correct)
incorrect <- apply(falseMatches, 2, function(x) Reduce("|", x))
table(incorrect)
both <- correct & incorrect
table(both)
matches[,both]
falseMatches[,both]
#Thus for each record if:
#1)No cRule, do nothing
#2)cRule exits but no wRule, mark cRule as a "Strong" cRule
#3)cRule and wRule exist, and cRule has greater precedence than wRule, mark cRule as a "Strong" cRule.
#4)cRule and wRule exist, and wRule has greater precedence than cRule, create a SetA structure and add to linked list of SetA structures.
strongRules <- vector('logical', length=length(rules.pruned))
rules.correct <- vector('numeric', length = length(rules.pruned))
incorrect <- vector('logical', length = length(titanic.mat))
incorrect[1:length(titanic.mat)] <- FALSE
for(i in 1:length(titanic.mat)){
match <- Reduce("|", matches[, i])
if(!match){next}
rule <- match(TRUE, matches[,i])
falseMatch <- Reduce("|", falseMatches[,i])
strong <- match & !falseMatch
orderedCorrect <- TRUE
orderedCorrect <- !falseMatch | rule < match(TRUE, falseMatches[,i])
strong <- strong | orderedCorrect
strongRules[rule] <- strong | strongRules[rule]
if(strong){
rules.correct[rule] <- rules.correct[rule] + 1
}
if(!orderedCorrect){
incorrect[i] <- TRUE
}
}
table(strongRules)
strongRules
table(incorrect)
incorrect.transactions <- titanic.mat[incorrect,]
str(incorrect)
for(i in 1:length(incorrect)){
if(!incorrect[i]){next}
wrule <- match(TRUE, falseMatches[,i])
is.strong.rule <- strongRules[wrule]
crule.exists <- Reduce('|', matches[,i])
if(is.strong.rule){
if(crule.exists){
crule <- match(TRUE, matches[,i])
rules.correct[crule] <- rules.correct[crule] - 1
}
rules.correct[wrule] <- rules.correct[wrule] + 1
}
if(crule.exists){
crule <- match(TRUE, matches[,i])
strongRules[crule] <- TRUE
}
####Override stuff (TODO)####
}
rules.for.classifier <- strongRules & rules.correct > 0
####Part 3 (TODO)####
inspect(rules.pruned[rules.for.classifier])
results <- vector('logical', length = length(titanic.mat))
results[1:length(results)] <- FALSE
rulesMatchLHS <- is.subset(rules.pruned[rules.for.classifier]@lhs, titanic.mat)
for(i in 1:length(titanic.mat)){
if(Reduce("|", rulesMatchLHS[,i])){
firstMatch <- match(TRUE, rulesMatchLHS[,i])
result <- rules.pruned[rules.for.classifier][firstMatch]@rhs
result <- as(result, "ngCMatrix")[10]
results[i] <- result == (titanic.raw$Survived[i] == "Survived=Yes")
}
}
table(results)
setwd("~/Dropbox/Summer 2016/CSE 5390/CBA_Algorithm")
load("titanic.raw.rdata")
str(titanic.raw)
require(arules)
rules <- apriori(titanic.raw, parameter = list(minlen=2, supp=0.005, conf=0.6), appearance = list(rhs=c("Survived=No", "Survived=Yes"), default="lhs"), control=list(verbose=FALSE))
rules.sorted <- sort(rules, by=c("confidence", "support", "lift"))
inspect(rules.sorted)
#subset.matrix <- is.subset(rules.sorted, rules.sorted)
#subset.matrix[lower.tri(subset.matrix, diag = TRUE)] <- NA
#redundant <- colSums(subset.matrix, na.rm = TRUE) >= 1
#which(redundant)
#rules.pruned <- rules.sorted[!redundant]
rules.pruned <- rules.sorted
inspect(rules.pruned)
titanic.mat <- as(titanic.raw, "transactions")
rulesMatchLHS <- is.subset(rules.pruned@lhs, titanic.mat)
rulesMatchRHS <- is.subset(rules.pruned@rhs, titanic.mat)
matches <- rulesMatchLHS & rulesMatchRHS
falseMatches <- rulesMatchLHS & !rulesMatchRHS
table(matches)
table(falseMatches)
inspect(rules.pruned)
#for(i in 1:2201){
#  inspect(rules.pruned[falseMatches[,i]])
#}
correct <- apply(matches, 2, function(x) Reduce("|", x))
table(correct)
incorrect <- apply(falseMatches, 2, function(x) Reduce("|", x))
table(incorrect)
both <- correct & incorrect
table(both)
matches[,both]
falseMatches[,both]
#Thus for each record if:
#1)No cRule, do nothing
#2)cRule exits but no wRule, mark cRule as a "Strong" cRule
#3)cRule and wRule exist, and cRule has greater precedence than wRule, mark cRule as a "Strong" cRule.
#4)cRule and wRule exist, and wRule has greater precedence than cRule, create a SetA structure and add to linked list of SetA structures.
strongRules <- vector('logical', length=length(rules.pruned))
rules.correct <- vector('numeric', length = length(rules.pruned))
incorrect <- vector('logical', length = length(titanic.mat))
incorrect[1:length(titanic.mat)] <- FALSE
for(i in 1:length(titanic.mat)){
match <- Reduce("|", matches[, i])
if(!match){next}
rule <- match(TRUE, matches[,i])
falseMatch <- Reduce("|", falseMatches[,i])
strong <- match & !falseMatch
orderedCorrect <- TRUE
orderedCorrect <- !falseMatch | rule < match(TRUE, falseMatches[,i])
strong <- strong | orderedCorrect
strongRules[rule] <- strong | strongRules[rule]
if(strong){
rules.correct[rule] <- rules.correct[rule] + 1
}
if(!orderedCorrect){
incorrect[i] <- TRUE
}
}
table(strongRules)
strongRules
table(incorrect)
incorrect.transactions <- titanic.mat[incorrect,]
str(incorrect)
for(i in 1:length(incorrect)){
if(!incorrect[i]){next}
wrule <- match(TRUE, falseMatches[,i])
is.strong.rule <- strongRules[wrule]
crule.exists <- Reduce('|', matches[,i])
if(is.strong.rule){
if(crule.exists){
crule <- match(TRUE, matches[,i])
rules.correct[crule] <- rules.correct[crule] - 1
}
rules.correct[wrule] <- rules.correct[wrule] + 1
}
if(crule.exists){
crule <- match(TRUE, matches[,i])
strongRules[crule] <- TRUE
}
####Override stuff (TODO)####
}
rules.for.classifier <- strongRules & rules.correct > 0
####Part 3 (TODO)####
inspect(rules.pruned[rules.for.classifier])
results <- vector('logical', length = length(titanic.mat))
results[1:length(results)] <- FALSE
rulesMatchLHS <- is.subset(rules.pruned[rules.for.classifier]@lhs, titanic.mat)
for(i in 1:length(titanic.mat)){
if(Reduce("|", rulesMatchLHS[,i])){
firstMatch <- match(TRUE, rulesMatchLHS[,i])
result <- rules.pruned[rules.for.classifier][firstMatch]@rhs
result <- as(result, "ngCMatrix")[10]
results[i] <- result == (titanic.raw$Survived[i] == "Survived=Yes")
}
}
table(results)
require(arules)
install.packages("arules")
require(arules)
install.packages("gmodels")
install.packages("arulesViz")
install.packages("arulesNBMiner")
require(arules)
install.packages("arules")
install.packages("arules")
